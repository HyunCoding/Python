딕셔너리 Dictionary

여러 값을 저장해두고 필요한 값을 꺼내쓰는기능
이름표를 이용하여 값을 꺼내서 사용

딕셔너리명 = {
    '이름표1':'값1',
    '이름표2':'값2'
    }

------------------------------------------------------------------------------------------------------------

          ↓ 이름표는 문자열 또는 숫자를 주로 사용하지만
dict = {"이름표":[1,2,3]}
                  ↑ 값은 리스트를 포함해서 무엇이든 올 수 있습니다.
ex) print(dict["이름표"]) = [1,2,3,]

------------------------------------------------------------------------------------------------------------

딕셔너리 수정하기
dict = {
    'one':1,
    'two':2
    }
추가 dict['three'] = 3
수정 dict['one'] = 11
삭제 del(dict['one']) / dict.pop('two')

------------------------------------------------------------------------------------------------------------

딕셔너리와 반복문
딕셔너리 반복문 활용 경우에 따라 가져올 값을 정할 수있다.

for key in ages.keys():   # keys() 생략 가능
    print(key)
for value in ages.values():
    print(value)

key와 value 둘다 가져올 수 있다.

for key, value in ages.items():
    print('{}의 나이는 {} 입니다'.format(key, value))

------------------------------------------------------------------------------------------------------------

딕셔너리는 값의 순서를 지키지 않는다.

------------------------------------------------------------------------------------------------------------

age = {'Tod':35 ,'Jane':23,'Paul':62}

for i in age.keys():   # keys() 생략가능 기본적으로 키값을 가지고 오도록 되어있다.
    print(i)

for i in age.values():
    print(i)

for i, j in age.keys():  # keys() 생략가능 기본적으로 키값을 가지고 오도록 되어있다.
    print('{}의 나이는 {}입니다'.format(i, age[i]))
    
for i, j in age.items():
    print('{}의 나이는 {}입니다'.format(i, j))
    
------------------------------------------------------------------------------------------------------------

딕셔너리와 리스트 비교
공통점
             List	                Dictionary
생성	     list = [ 1, 2 ,3 ]  	dict = {'one':1, 'two':2}
호출	     list[0]	            dict['one']
삭제	     del( list[0] )         del( dict['one'])
           list.remove(3)
개수 확인  len(list)	            len(dict)
값 확인	 2 in list	            'two' in dict.keys()  / 2 in dict.values()
전부 삭제  list.clear()	         dict.clear()

차이점
            List	        Dictionary
순서	삭제 시 순서가 바뀌기 때문에 인덱스에 대한 값이 바뀐다	key로 값을 가져오기 때문에 삭제 여부와 상관없다
결합	list1 + list2	dict1.update( dict2 )

------------------------------------------------------------------------------------------------------------

딕셔너리 결합시 주의사항

결합시 이름명이 똑같을 경우 동일한 이름명중 업데이트된 이름명의 값으로 변경된다. 
dict1 = {1:100,2:200}
dict2 = {1:1000,3:300}

dict1.update(dict2) = {1:1000,2:200,3:300}  # dict2의 1의 값으로 결합됨
dict2.update(dict1) = {1:100,2:200,3:300}   # dict1의 1의 값으로 결합됨

------------------------------------------------------------------------------------------------------------

Dictionary
Dictionary Comprehension
파이썬의 유용한 도구

예시
{ "{}번".format(number):name for number, name in enumerate(students) } # [ 형식 for문 ]
{student:score for student, score in zip(students, scores)}

------------------------------------------------------------------------------------------------------------

Dictionary Comprehension을 이용한 문제입니다.

students = ["태연", "진우", "정현", "하늘", "성진"]
{"{}번".format(number):name for number, name in enumerate(students)}
    # {'2번': '정현', '0번': '태연', '1번': '진우', '4번': '성진', '3번': '하늘'}

students = ["태연", "진우", "정현", "하늘", "성진"]
scores = [85, 92, 78, 90, 100]
result = {x : y for x, y in zip(students, scores)}
    # {'성진': 100, '진우': 92, '하늘': 90, '태연': 85, '정현': 78}

  @zip은 두 개 이상의 리스트나 스트링을 받아서 인덱스에 맞게 자료를 묶어주는 역할을 합니다.

product_list에는 상품의 목록이 들어 있고, price_list에는 각 상품의 가격이 순서대로 들어있습니다. 
딕셔너리 컴프리헨션을 이용해서 product_dict를 상품의 이름을 키로 가지고, 가격을 값으로 가지는 딕셔너리로 만들어보세요.

product_list = ["풀", "가위", "크래파스"]
price_list = [800, 2500, 5000]
product_dict = { a : b for a, b in zip(product_list,price_list)}


print(product_dict)