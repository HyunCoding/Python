# Hello world   /  프린트함수 사용하여 hello, world 출력해보기
#  ex) print('hello, world')

# ;(세미콜론)
# 많은 프로그래밍 언어들은 구문이 끝날 때 ;(세미콜론)을 붙여야 합니다. 하지만 파이썬은 세미콜론을 붙이지 않습니다.
# 단, 세미콜론을 붙여도 문법 에러는 발생하지 않습니다. 보통 한 줄에 여러 구문을 사용할 때 세미콜론으로 구분해줍니다.
#  ex) print('Hello'); print('1234')


# 숫자의 자료형
# 정수 = int   /   실수 = float   /   복소수 = complex

# 사칙연산 ( '+' , '-' , '*' , '/' )

# 나누기 조심해야할점
#  ex) 4 / 2 = 2.0 (실수) 
#  ex) 6 // 3 = 3 (정수)
# 나눗셈 후 소수점 이하를 버리는 연산자 ' // '
#  ex) 4 // 2 = 2 (정수)
#  ex) 5.5 / 2 = 2.0 (소수점 이하는 버리기 떄문에 결과는 항상 '.0'으로 끝남)

# 연산자 종류
# 나머지를 구하는 연산자 %
#  ex) 10 % 3 = 1 , 5 % 3 = 2

# 몫을 구하는 연산자 / , //
#  ex) 4 / 2 = 2.0 (실수) 
#  ex) 6 // 3 = 3 (정수)

# 몫과 나머지를 함께 구하는 divmod() 함수 이용하기 (결과값이 튜플로 나옴)
#  ex) divmod(5, 2) = (2, 1)

# 제곱을 구하는 연산자 **
#  ex) 3 ** 2 = 9



# 값을 정수(int)로 만들기
#  ex) int(3.3) = 3 , int(5 / 2) = 2 , int('10') = 10 -> (문자열을 정수로 만들기)

# 값을 실수(float)로 만들기
#  ex) float(숫자)  /  float(5) = 5.0
#  ex) float(계산식)  /  float(1 + 2) = 3.0
#  ex) float('문자열')  /  float('5.3') = 5.3

# 값을 복소수(complex)로 만들기
# 파이썬에서는 실수부와 허수부로 이루어진 복소수(complex number)도 사용할 수 있습니다. 이때 허수부는 숫자 뒤에 j를 붙입니다(수학에서는 허수를 i로 표현하지만 공학에서는 j를 사용합니다).
# 두 실수를 복소수로 만들 때는 complex를 사용하면 됩니다.
#  ex) complex(1.2, 1.3) = (1.2+1.3j)


# 실수 계산하기
#  ex) 3.5 + 2.1 = 5.6
#  ex) 4.3 - 2.7 = 1.5999999999999996
#  ex) 1.5 * 3.1 = 4.65
#  ex) 5.5 / 3.1 = 1.7741935483870968
# 4.3 - 2.7의 결과가 좀 이상합니다. 1.6이 나와야 하는데 1.5999999999999996이 나왔습니다. 왜냐하면 컴퓨터는 실수를 표현할 때 오차가 발생하기 때문입니다.
# 오차 문제는 다소 어려운 주제이므로 지금은 크게 신경 쓰지 않아도 됩니다. 나중에 실무에서 실수를 다룰 때 오차에 대한 적절한 처리가 필요합니다


# 객체(object)의 자료형 알아내기 type(값)
#  ex) type(10) = class int ( 자료형 정수(int)이다. )


# 2진수, 8진수, 16진수

#  정수는 10진수 이외에도 2진수, 8진수, 16진수로도 표현할 수 있습니다.
# 2진수: 숫자 앞에 0b를 붙이며 0과 1을 사용합니다.
# 8진수: 숫자 앞에 0o(숫자 0과 소문자 o)를 붙이며 0부터 7까지 사용합니다.
# 16진수: 숫자 앞에 0x 또는 0X를 붙이며 0부터 9, A(10)부터 F(15)까지 사용합니다(소문자 a부터 f도 가능).

# ex) 0b110 = 6  2진수
# ex) 0o10 = 8   8진수
# ex) 0xF = 15   16진수

# ------------------------------------------------------------------------------------------------------------

# 숫자와 문자열

# 숫자

#   변수에 숫자를 넣는 예

# my_age = 25

#   숫자는 계산이 가능

# 더하기 +
# my_next_age = my_age + 1

# 곱하기 *
# multiply = 9 * 9

# 나누기 /
# divide = 30 / 5

# 거듭제곱 ** (예. 2의 10승)
# power = 2 ** 10

# 나머지 %
# remainder = 15 % 4
# 15를 4로 나눈 다음의 나머지 = 3


# 문자열
# 따옴표로 감싸진 글

# 변수에 문자열을 넣는 예
# my_name = 'Python'

# 텍스트 두개를 더하면 문자열이 이어붙여짐
# text = '2015' + '1991'하고 나면 text에는 '20151991'이라는 값이 저장

# 텍스트는 더하기만 가능하고, 빼기(-)등 다른 계산은 불가능

# ------------------------------------------------------------------------------------------------------------

# if문
# 조건문

# 특정 조건에 따라 다른 동작을 할 수 있도록 해 주는 구문
# if people > apple:
#     print('사람이 너무 많아! 몇 명은 못먹겠네')   

# 구조
# if 예약어 : 조건문의 시작을 알림

# 조건: people > apple와 같이 참/거짓을 판단할 수 있는 조건

# : 조건이 끝났다는걸 표현한하는 명령

# 실행하고자 하는 코드. 코드는 탭키를 이용해서 들여서 쓴다.
#   예. print('사람이 너무 많아! 몇 명은 못먹겠네')

# ------------------------------------------------------------------------------------------------------------

# if True:
#     print("조건식이 True이면 실행됩니다.")

# if False:
#     print("조건식이 False이면 실행되지 않습니다.")

# ------------------------------------------------------------------------------------------------------------

# 조건식
# 조건

# 숫자 비교

# 크다
# 0 < 10
# 10 > 11

# 크거나 같다, 작거나 같다
# 3 <= 10
# 15 >= 10

# 같다
# 5 == 5

# 같지 않다
# 5 != 10

# 비교의 결과는 True 또는 False

# ------------------------------------------------------------------------------------------------------------

# boolean연산

# and연산
# 두 조건이 모두 참인지를 체크

# or
# 두 조건 중 하나라도 참이다

# not
# true/false를 뒤집기 위해 사용

# 예. a는 20대이다.
# 20 <= a and a < 30

# 예시. a는 18세 미만 또는 60세 이상이다.
# a < 18 or 60 <= a

# ------------------------------------------------------------------------------------------------------------

# if else

# else
# if의 조건이 맞지 않는 경우 항상 실행
# 반드시 if뒤에 나와야 한다.

#     if mine == yours:
#         result = DRAW
#     else:
#         result = '이기거나 지거나'

# elif
# else 와 if의 결합으로 조건이 맞지 않는 경우 다른 경우를 검사
# 기능의 차이가 아닌 보이는 것의 차이

#     if mine == SCISSOR:
#         result = '가위'   # 조건이 참일 때 실행
#     elif mine == ROCK:
#         result = '바위'   # 다른 조건이 참일 때 실행
#     else:
#         result = '나머지'    # 조건이 거짓일 때 실행

# ------------------------------------------------------------------------------------------------------------

# 함수 만들기

# 함수는 코드의 덩어리에 이름을 붙인 것이다.

# 새 함수를 정의할 수 있다.

# print는 미리 만들어진 함수이다.

# 함수를 한번 만들고 나면, 그 안은 잊어버려도 좋다.

# def function():         # 함수의 정의
#     print('안녕, 함수!')

# print('첫줄 실행')
# function()          # 함수의 호출
# print('끝줄 실행')

# ------------------------------------------------------------------------------------------------------------

# 매개변수
# 함수를 정의할 때 사용하는 이름

# 실행 인자
# 함수를 실행할 때 넘기는 변수, 값

# 매개변수와 실행 인자
# 매개변수와 실행 인자의 개수는 동일해야 한다.
# 여러 개일 경우 쉼표로 구분

# def print_round(number):    # 함수의 정의
#     rounded = round(number)
#     print(rounded)  

# print_round(4.6)        # 함수의 호출
# print_round(2.2)

# ------------------------------------------------------------------------------------------------------------

# 함수의 값

# return을 이용해 값을 돌려줄 수있다.

#     def add_10(value):
#         result = value + 10
#         return result

#     n = add_10(5)
#     print(n)

# 여러 값 반환

# return 뒤에 여러 값을 쉼표로 구분해서 값을 보내고, 받을때도 쉼표로 구분하여 받는다.

# ------------------------------------------------------------------------------------------------------------

# format
# 문자열.format()

# 문자열의 대괄호 자리에 format 뒤의 괄호안에 들어있는 값을 하나씩 넣는다

# 문자열에 포함된 대괄호 개수 보다 format안에 들어 있는 값의 수가 많으면 정상 동작
# print('{} 번 손님'.format(number,greeting))

# 문자열에 포함된 대괄호 개수 보다 format안에 들어 있는 값의 수가 적으면 에러
# print('{} 번 손님 {}'.format(number))


# number = 20
# welcome = '환영합니다'
# base = '{} 번 손님 {}'

#      #아래 3개의 print는 같은 값을 출력
# print(number,'번 손님',welcome)
# print(base.format(number,welcome))
# print('{} 번 손님 {}'.format(number,welcome))
#      #=>20 번 손님 환영합니다

# ------------------------------------------------------------------------------------------------------------

# 사용자 입력 받기

# 프로그래밍의 3단계
#  1.사용자 입력
#  2.자료 처리
#  3.결과 출력

# input()
# 사용자의 키보드 입력을 return

# print('가위 바위 보 중 하나를 내주세요> ', end = ' ')
# mine = input()
# print('mine:', mine)


# 간단한 print기능을 내장

# mine = input('가위 바위 보 중 하나를 내주세요> ')
# print('mine:', mine)

# Ctrl + c  프로그램 즉시 종료

# ------------------------------------------------------------------------------------------------------------

# 리스트 사용

# 안내
# 강의에서 []를 중괄호라고 말하는 부분이 있어, 정정합니다. []는 중괄호가 아니라 대괄호입니다.

# List
# 여러개의 값을 담을 수 있는 변수
#   list1 = [1,2,3,4,5]

# 값 읽어오기

# 리스트를 사용할때는 0번째가 첫번째
# 첫번째 값 list1[0]
# 두번째 값 list1[1]
# 뒤에서 첫번째 값 list1[-1]
# 뒤에서 두번째 값 list1[-2]

# 리스트에 들어있는 값 보다 큰 값을 읽어오려고 하면 에러
# 예. 위의 list1에서 list1[5] 또는 list1[-6]은 에러

# 값 쓰기
# 변수와 같이 list1[0]=10이라고 하면 list의 첫번째 값이 10으로 변경

# ------------------------------------------------------------------------------------------------------------

# 리스트 수정
# 리스트에 새로운 값을 추가하는 방법

# list1=[1,2,3]이라고 할 때
# append를 이용
# list1.append(4)
# append를 이용하면 리스트에 새로운 값이 추가된다.

# 뒤에 새로운 리스트를 더하기
# list2=list1+[4]
# list1은 그대로 두고, 새로운 리스트를 만들어 낸다.


# 리스트에 값이 들어있는지 확인하는 방법
# in 연산을 이용
# #12라는 값이 리스트에 들어있는지 확인하는 코드
# n=12
# if n in list1:
#     print('{}가 리스트에 있다.'.format(n))


# 리스트에서 필요 없는 값을 지우는 방법

# 1.del을 이용해서 특정 위치의 값을 지우기
#   del list1[10] 리스트의 10번째 값을 지워라

# 2.remove를 이용해서 특정 값을 지우기
#   list1.remove(40)을 하면 리스트에 40이라는 값이 있는경우 삭제
#   여러개의 값이 있는 경우 가장 앞에 있는 하나만 지워짐

# ------------------------------------------------------------------------------------------------------------

# for in list

# for in 반복문
# 코드를 필요한만큼 반복해서 실행

# for pattern in patterns:
#     print (pattern)

# 리스트 patterns의 값을 하나씩 꺼내 pattern으로 전달
# 리스트의 길이만큼 print (pattern) 실행

# ------------------------------------------------------------------------------------------------------------

# for in range
# range 함수
# 필요한 만큼의 숫자를 만들어내는 유용한 기능

# for i in range(5):
#     print(i)


# enumerate
# 리스트가 있는 경우 순서와 리스트의 값을 전달하는 기능

# names = ['철수', '영희', '영수']
# for i, name in enumerate(names):
#     print('{}번: {}'.format(i + 1, name))

# ------------------------------------------------------------------------------------------------------------

# 모듈 사용하기
# import math

# import math
# r = 10
# 파이 = 2 * math.pi * r
# print(파이)

# ------------------------------------------------------------------------------------------------------------

# from random import*
# import random

# Hlist = []

# for i in range(45):
#     Hlist.append(i+1)

# print(Hlist)
# lotto = random.sample(Hlist, 6)
# lotto.sort()
# print(lotto)

# ------------------------------------------------------------------------------------------------------------

# lotto2 = random.sample(range(1,46), 6)
# lotto2.sort()
# print(lotto2)

# ------------------------------------------------------------------------------------------------------------

# moves = [1,5,3,5,1,2,1,4]
# print(moves)
# moves = list(map(lambda a : a-1, moves))
# print(moves)

# a = list(range(10, -10, -2))
# print(a)

# ------------------------------------------------------------------------------------------------------------

# 딕셔너리 Dictionary
# 여러 값을 저장해두고 필요한 값을 꺼내쓰는기능
# 이름표를 이용하여 값을 꺼내서 사용
# 딕셔너리명 = {
#     '이름표1':'값1',
#     '이름표2':'값2'
#     }

# ------------------------------------------------------------------------------------------------------------

#           ↓ 이름표는 문자열 또는 숫자를 주로 사용하지만
# dict = {"이름표":[1,2,3]}
#                   ↑ 값은 리스트를 포함해서 무엇이든 올 수 있습니다.
# ex) print(dict["이름표"]) = [1,2,3,]

# ------------------------------------------------------------------------------------------------------------

# 딕셔너리 수정하기
# dict = {
#     'one':1,
#     'two':2
#     }
# 추가 dict['three'] = 3
# 수정 dict['one'] = 11
# 삭제 del(dict['one']) / dict.pop('two')

# ------------------------------------------------------------------------------------------------------------

# 딕셔너리와 반복문
# 딕셔너리 반복문 활용 경우에 따라 가져올 값을 정할 수있다.

# for key in ages.keys():   # keys() 생략 가능
#     print(key)
# for value in ages.values():
#     print(value)

# key와 value 둘다 가져올 수 있다.

# for key, value in ages.items():
#     print('{}의 나이는 {} 입니다'.format(key, value))

# ------------------------------------------------------------------------------------------------------------

# 딕셔너리는 값의 순서를 지키지 않는다.

# ------------------------------------------------------------------------------------------------------------

# age = {'Tod':35 ,'Jane':23,'Paul':62}

# for i in age.keys():   # keys() 생략가능 기본적으로 키값을 가지고 오도록 되어있다.
#     print(i)

# for i in age.values():
#     print(i)

# for i, j in age.keys():  # keys() 생략가능 기본적으로 키값을 가지고 오도록 되어있다.
#     print('{}의 나이는 {}입니다'.format(i, age[i]))
    
# for i, j in age.items():
#     print('{}의 나이는 {}입니다'.format(i, j))
    
# ------------------------------------------------------------------------------------------------------------

# 딕셔너리와 리스트 비교
# 공통점
#              List	                Dictionary
# 생성	     list = [ 1, 2 ,3 ]  	dict = {'one':1, 'two':2}
# 호출	     list[0]	            dict['one']
# 삭제	     del( list[0] )         del( dict['one'])
#            list.remove(3)
# 개수 확인  len(list)	            len(dict)
# 값 확인	 2 in list	            'two' in dict.keys()  / 2 in dict.values()
# 전부 삭제  list.clear()	         dict.clear()

# 차이점
#             List	        Dictionary
# 순서	삭제 시 순서가 바뀌기 때문에 인덱스에 대한 값이 바뀐다	key로 값을 가져오기 때문에 삭제 여부와 상관없다
# 결합	list1 + list2	dict1.update( dict2 )

# ------------------------------------------------------------------------------------------------------------

# 딕셔너리 결합시 주의사항

# 결합시 이름명이 똑같을 경우 동일한 이름명중 업데이트된 이름명의 값으로 변경된다. 
# dict1 = {1:100,2:200}
# dict2 = {1:1000,3:300}

# dict1.update(dict2) = {1:1000,2:200,3:300}  # dict2의 1의 값으로 결합됨
# dict2.update(dict1) = {1:100,2:200,3:300}   # dict1의 1의 값으로 결합됨

# ------------------------------------------------------------------------------------------------------------

# 튜플 

# 한번 정해진 순서를 바꿀 수 없다.

# 튜플 만드는방법
# tuple1 = (1, 2, 3, 4)

# tuple2 = 1, 2, 3, 4

# mylist = [1,2,3,4]
# tuple3 = tuple(mylist)

# 튜플은 값의 변경과 삭제가 불가능

# ------------------------------------------------------------------------------------------------------------

# packing, unpacking

# packing
# 하나의 변수에 여러개의 값을 넣는 것

# unpacking
# 패킹된 변수에서 여러개의 값을 꺼내오는 것

# c = (3, 4)
# d, e = c    # c의 값을 언패킹하여 d, e에 값을 넣었다
# f = d, e    # 변수 d와 e를 f에 패킹

# 튜플의 활용

# 두 변수의 값을 바꿀 때 임시변수가 필요 없다.
# x = 1
# y = 2
# x,y = y,x => x = 2 , y = 1 값을 바로 바꿀수 있다.

# 함수의 리턴 값으로 여러 값을 전달할 수 있다.

# ------------------------------------------------------------------------------------------------------------

# 튜플을 이용한 함수의 리턴값

# 튜플 리스트 활용  
# for a in enumerate(list):
#     print('{}번째 값: {}'.format(a[0], a[1]))

# for a in enumerate(list):
#     print('{}번째 값: {}'.format(*a))


# 튜플 딕셔너리 활용
# for a in dict.items():
#     print('{}의 나이는:{}'.format(a[0], a[1]))

# for a in dict.items():
#     print('{}의 나이는:{}'.format(*a))

# *a의 뜻은 튜플 a의 값을 나눠받으라는 표시
# a[0],a[1] = *a 서로 같은뜻

# ------------------------------------------------------------------------------------------------------------

# while문 쓰기

# 조건이 참인 경우 계속 실행하는 반복문

# while selected not in ['가위', '바위', '보']:
#     selected = input('가위, 바위, 보 중에 선택하세요>')
# for 반복문으로 작성한 코드는 while 반복문으로 작성 할 수 있다.

# ------------------------------------------------------------------------------------------------------------

# break, continue

# break
# 반복문을 종료시키는 기능

# sizes에는 진열된 바지 사이즈의 목록이 들어 있습니다. 다음 코드는 사이즈가 32인 바지의 위치를 모두 출력하고 있는데요.
# 5번째줄을 수정해서 사이즈가 32인 바지의 위치를 한 번만 출력하고 프로그램이 종료되도록 만들어 보세요.
# sizes = [33,35,34,37,32,35,39,32,35,29]
# for i,size in enumerate(sizes):
#     if size == 32:
#         print("사이즈 32인 바지는 {}번째에 있다.".format(i+1))
#         break# 여기에 코드를 추가하세요


# continue
# 반복문의 나머지 부분을 보지 않고, 반복문의 처음으로 돌아가는 기능

# 다음 코드는 numbers에 있는 튜플을 받아들여서 튜플의 첫번째 숫자를 두번째 숫자로 나누는 일을 합니다. 
# 이 때, b가 0이면 "0으로 나눌 수는 없습니다."라고 출력하는데요. 
# 이 if else문에서 continue문을 이용하여 else를 사용하지 않도록 변경해 보세요.
# numbers = [ (1,2),(10,0) ]

# for a,b in numbers:
#     if b == 0:
#         print("0으로 나눌 수는 없습니다.")
#         continue# 이 부분이 else문에 들어있지 않도록 수정해야 합니다.
#     print("{}를 {}로 나누면 {}".format(a,b,a/b))

# ------------------------------------------------------------------------------------------------------------

# try except 예외 처리

# try:
#     # 에러가 발생할 가능성이 있는 코드
# except Exception: # 에러 종류
#     #에러가 발생 했을 경우 처리할 코드

# 경우에 따라 예외 처리 대신 if else를 사용 할 수 있다.

# try:
#     a = 3/0
# except ZeroDivisionError:
#     print("0으로 나눌 수 없습니다.")

# ------------------------------------------------------------------------------------------------------------

# 예외의 이름을 모를 때
# 예외 이름을 모르는 경우 처리 방법

# try:
#     # 에러가 발생할 가능성이 있는 코드
# except Exception as ex: # 에러 종류
#     print('에러가 발생 했습니다', ex) # ex는 발생한 에러의 이름을 받아오는 변수

# try:
#     a = 5
#     b = 0
#     c = a / b
# except Exception as ex:
#     print('다음과 같은 에러가 발생했습니다: {}'.format(ex))

# ------------------------------------------------------------------------------------------------------------

# raise 예외 발생
# 사용자가 직접 에러를 발생시키는 기능

# raise Exception # 에러 종류
# 많이 사용하면 코드를 읽기 어려워진다.


# shops = {
#     "송일문방구": {"가위": 500, "크레파스": 3000},
#     "알파문구": {"풀": 800, "도화지": 300, "A4용지": 8000},
#     "다이소": {"풀": 500, "목공본드": 2000, "화분": 3000}
# }
# for shop, products in shops.items():
#     for product, price in products.items():
#         if product =='풀':
#             print("{}: {}원".format(shop, price))


# StopIteration 예외처리
# 더이상 값을 가져오고 싶지않을때 쓰는 예외처리

# 풀을 파는 가게를 발견하면 for문 전체를 즉시 종료하고 싶습니다. 
# for 문을 try/except로 감싸고 print문 다음에 raise StopIteration을 추가해서 풀을 파는 가게를 하나만 출력하도록 만들어 보세요.
# except문에서는 StopIteration을 지정해 주어야 합니다.

# shops = {
#     "송일문방구": {"가위": 500, "크레파스": 3000},
#     "알파문구": {"풀": 800, "도화지": 300, "A4용지": 8000},
#     "다이소": {"풀": 500, "목공본드": 2000, "화분": 3000}
# }
# try:
#     for shop, products in shops.items():
#         for product, price in products.items():
#             if product =='풀':
#                 print("{}: {}원".format(shop, price))
#                 raise StopIteration
# except StopIteration:
#     print('종료')

# ------------------------------------------------------------------------------------------------------------

# 논리연산 더 알아보기
# 단락평가
# 논리연산에서 코드의 앞만 보고 값을 정할 수 있는 경우 뒤는 보지 않고 값을 결정
# 복잡한 코드를 단순하게 하는 방식

# bool 값과 논리연산
# true, false
# 숫자 0을 제외한 모든 수 - true
# 빈 딕셔너리, 빈 리스트를 제외한 모든 딕셔너리, 리스트 - true
# 아무 값도 없다는 의미인 None - false
# 빈문자열을 제외한 모든 문자열 - true

# ------------------------------------------------------------------------------------------------------------

# List의 다양한 기능
# List의 기능
# list.index( value ) : 값을 이용하여 위치를 찾는 기능
# list.extend( [value1, value2] ) : 리스트 뒤에 값을 추가
# list.insert( index, value ) : 원하는 위치에 값을 추가하고 그자리에 있던값은 오른쪽으로 보냄
# list.sort( ) : 값을 순서대로 정렬
# list.reverse( ) : 값을 역순으로 정렬


# list1 = [1, 2, 3, 4]

# # 아래줄에서 list1의 1번째 자리에 8을 넣고 원래 있던 값은 오른쪽으로 밀어 보세요.
# list1.insert(0,8)
# print("첫 번째 자리에 8을 넣은 결과 : {}".format(list1))
# 첫 번째 자리에 8을 넣은 결과 : [8, 1, 2, 3, 4]

# # 아래줄에서 list1을 작은 수부터 큰 수로 정렬해 보세요
# list1.sort()
# print("list1을 작은 수부터 큰 수로 정렬한 결과 : {}".format(list1))
# list1을 작은 수부터 큰 수로 정렬한 결과 : [1, 2, 3, 4, 8]

# # 아래줄에서 list1을 거꾸로 만들어 보세요
# list1.reverse()
# print("list1을 거꾸로 정렬한 결과 : {}".format(list1))
# list1을 거꾸로 정렬한 결과 : [8, 4, 3, 2, 1]

# ------------------------------------------------------------------------------------------------------------

# List와 문자열
# List와 String
# 리스트와 문자열은 유사하다.
# 서로 변환이 가능하다.
# list = str.split( ) : 문자열에서 리스트로
# " ".join( list ) : 리스트에서 문자열으로

# ------------------------------------------------------------------------------------------------------------

# Slice
# slicing
# 리스트나 문자열에서 값을 여러개 가져오는 기능
# text = "hello world"
# text = text[ 1:5 ]

# list = [ 0, 1, 2, 3, 4, 5 ]
# list = list[ 1:3 ]
# slice를 하면 해당하는 부분의 리스트나 문자열을 새로 만들어 준다.

# 시작과 끝부분을 얻어 오는 방법

# list[ 2: ] : 2번째부터 끝까지 반환
# list[ : 2 ] : 처음부터 2번째 까지 반환
# list[ : ] : 처음부터 끝까지 전부 반환

# ------------------------------------------------------------------------------------------------------------

# Slice의 step
# step
# slice한 값의 범위에서 step 값을 주어 그 값만큼 건너뛰어 가져오는 기능
# list[ 시작값:끝값:step ]


# list1 = list(range(20))

# # new_list가 5, 8, 11, 14의 값을 가지도록 list1을 slice하세요
# new_list = list1[5:15:3]

# print(new_list)

# # reverse_list가 17, 13, 9, 5의 값을 가지도록 list1을 slice하세요
# reverse_list = list1[17:4:-4]

# print(reverse_list)

# ------------------------------------------------------------------------------------------------------------

# Slice로 리스트 수정하기
# slice 활용
# 삭제
# del list[ :5 ] : 처음부터 5번째까지 삭제.
# 수정
# list[ 1:3 ] = [ 77, 88 ]
# list[ 1:3 ] = [ 77, 88 ,99 ] : 더 많은 개수로 변환
# list[ 1:4 ] = [ 8 ] : 더 적은 개수로 변환

# ------------------------------------------------------------------------------------------------------------

# 자료형 다루기
# 자료형
# type( a ) # type( 변수명 ) : 자료형
# isinstance( 42, int ) # isinstance( 값, 자료형 ) : 자료형 검사

# ------------------------------------------------------------------------------------------------------------

# 클래스 만들기
# 클래스 선언
# class Human( ):
#     '''사람'''
# 인스턴스 생성
# person1 = Human( )
# person2 = Human( )
# 클래스와 인스턴스를 이용하면 데이터와 코드를 사람이 이해하기 쉽게 포장할 수 있다.

# 모델링
# 모델링(modeling)
# 클래스로 현실의 개념을 표현하는 것

# ------------------------------------------------------------------------------------------------------------

# 메소드 이해하기
# 메소드(Method)
# 메소드는 함수와 비슷하다.
# 클래스에 묶여서 클래스의 인스턴스와 관계되는 일을 하는 함수

# 클래스 내부에 함수를 포함시킨 예
# class Human( ):
#     '''인간'''
#     def create( name, weight ): # 다음 강의에서 자세히 설명
#         person = Human()
#         person.name = name
#         person.weight = weight
#         return person

#     def eat( self ):
#         self.weight += 0.1
#         print("{}가 먹어서 {}kg이 되었습니다".format(self.name, self.weight))

#     def walk( self ):
#         self.weight -= 0.1
#         print("{}가 걸어서 {}kg이 되었습니다".format(self.name, self.weight))

# person = Human.create("철수", 60.5)
# person.eat()

# self
# 메소드의 첫번째 인자
# 인스턴스의 매개변수를 전달 할 때는 self 매개변수는 생략하고 전달

# ------------------------------------------------------------------------------------------------------------

# 특수한 메소드

# 초기화 함수
# __init__ : 인스턴스를 만들 때 실행되는 함수

# 문자열화 함수
# __str__ : 인스턴스 자체를 출력 할 때의 형식을 지정해주는 함수

# class Human( ):
#     '''인간'''
#     def __init__( self, name, weight ):
#         '''초기화 함수'''
#         self.name = name
#         self.weight = weight

#     def __str__( self )
#         '''문자열화 함수
#         return "{} ( 몸무게 {}kg )".format( self.name, self.weight )

# person = Human( "사람", 60.5 ) # 초기화 함수 사용
# print( person ) # 문자열화 함수 사용

# ------------------------------------------------------------------------------------------------------------

# 상속(Inheritance)

# 상속하는 클래스를 부모 클래스
# 상속받는 클래스를 자식 클래스

# 자식 클래스가 부모 클래스의 내용을 가져다 쓸 수 있는 것

# class Animal( ):
#     def walk( self ):
#         print( "걷는다" )

#     def eat( self ):
#         print( "먹는다" )

# class Human( Animal ):
#     def wave( self ):
#         print( "손을 흔든다" )

# class Dog( Animal ):
#     def wag( self ):
#         print( "꼬리를 흔든다" )

# ------------------------------------------------------------------------------------------------------------

# 단순 오버라이드(Override)
# 같은 이름을 가진 메소드를 덮어 쓴다는 의미

# class Animal( ):
#     def greet( self ):
#         print( "인사한다" )

# class Human( Animal ):
#     def greet( self ):
#         print( "손을 흔든다" )

# class Dog( Animal ):
#     def greet( self ):
#         print( "꼬리를 흔든다" )

# ------------------------------------------------------------------------------------------------------------

# super() 

# 자식클래스에서 부모클래스의 내용을 사용하고 싶은 경우
# super().부모클래스내용

# class Animal( ):
#     def __init__( self, name ):
#         self.name = name

# class Human( Animal ):
#     def __init__( self, name, hand ):
#         super().__init__( name ) # 부모클래스의 __init__ 메소드 호출
#         self.hand = hand

# person = Human( "사람", "오른손" )

# ------------------------------------------------------------------------------------------------------------

# 내 예외 만들기
# 예외 정의
# 사용자가 직접 예외처리를 하면 코드의 직관성을 높일 수 있다.
# 파일을 하나 만들어 예외를 정의
# Exception 클래스를 상속받아 만든다

# try:
#     sign_up( )
# except BadUserName:
#     print( "이름으로 사용할 수 없는 입력" )
# except PasswordNotMatched:
#     print( "입력한 패스워드 불일치")


# 다음 코드는 문구점 3곳을 검사하면서 풀이 있으면 문구점의 이름과 가격을 출력하고 
# MyException을 raise해서 즉시 for in문 전체를 종료합니다. 
# 코드의 2번째 줄에 Exception클래스를 상속받는 MyException이라는 예외 클래스를 만들어 보세요.

# class MyException(Exception):
#     pass

# shops = {
#     "송일문방구": {"가위": 500, "크레파스": 3000},
#     "알파문구": {"풀": 800, "도화지": 300, "A4용지": 8000},
#     "다이소": {"풀": 500, "목공본드": 2000, "화분": 3000}
# }

# try:
#     for shop, products in shops.items():
#         for product, price in products.items():
#             if product == '풀':
#                 print("{}: {}원".format(shop, price))
#                 raise MyException
# except MyException:
#     print("풀을 찾았습니다.")

# ------------------------------------------------------------------------------------------------------------

# List
# List Comprehension
# 파이썬의 유용한 도구

# 예1 [ i*i for i in range(1,11) ] # [ 계산식 for문 ]

# 예2 [ i*i for i in range(1,11) if i % 2 == 0 ] # [ 계산식 for문 조건문 ]

# 예3 [ ( x, y ) for x in range(15) for y in range(15) ] # [ 계산식 for문 for문 ]


# Dictionary
# Dictionary Comprehension
# 파이썬의 유용한 도구

# 예시
# { "{}번".format(number):name for number, name in enumerate(students) } # [ 형식 for문 ]
# {student:score for student, score in zip(students, scores)}

# ------------------------------------------------------------------------------------------------------------

# Dictionary Comprehension을 이용한 문제입니다.

# students = ["태연", "진우", "정현", "하늘", "성진"]
# {"{}번".format(number):name for number, name in enumerate(students)}
#     # {'2번': '정현', '0번': '태연', '1번': '진우', '4번': '성진', '3번': '하늘'}

# students = ["태연", "진우", "정현", "하늘", "성진"]
# scores = [85, 92, 78, 90, 100]
# result = {x : y for x, y in zip(students, scores)}
#     # {'성진': 100, '진우': 92, '하늘': 90, '태연': 85, '정현': 78}

#   @zip은 두 개 이상의 리스트나 스트링을 받아서 인덱스에 맞게 자료를 묶어주는 역할을 합니다.

# product_list에는 상품의 목록이 들어 있고, price_list에는 각 상품의 가격이 순서대로 들어있습니다. 
# 딕셔너리 컴프리헨션을 이용해서 product_dict를 상품의 이름을 키로 가지고, 가격을 값으로 가지는 딕셔너리로 만들어보세요.

# product_list = ["풀", "가위", "크래파스"]
# price_list = [800, 2500, 5000]
# product_dict = { a : b for a, b in zip(product_list,price_list)}


# print(product_dict)

# ------------------------------------------------------------------------------------------------------------

# datetime
# datetime 모듈
# 날짜와 시간을 사용하게 해주는 라이브러리


# christmas_2016이 2016년 12월25일을 값으로 가지는 datetime클래스의 인스턴스가 되도록 만들어 보세요.

# import datetime
# christmas_2016 = datetime.datetime(2016,12,25)
# print(christmas_2016)


# datetime은 날짜와 시간을 사용 할 수 있게 해주는 라이브러리입니다.
# 원하는 날짜와 시간으로 인스턴스를 만들기 위해서는 아래의 예와 같이 사용합니다.

# start_time = datetime.datetime(2016, 2, 1)

# ------------------------------------------------------------------------------------------------------------

# 코드의 5번째 줄을 수정해서 days_until_christmas 함수가 오늘부터 2030년 12월 25일 사이에 몇일이 있는지를 리턴하도록 만들어 보세요.
# (단, 시간단위는 고려하지 마세요.)

# import datetime

# def days_until_christmas():
#     christmas_2030 = datetime.datetime(2030, 12, 25)
#     days = christmas_2030 - datetime.datetime.now()
#     return days.days

# print("{}일".format(days_until_christmas()))


# datetime은 -연산을 지원 합니다.
# 예를 들면,

# start_time = datetime.datetime()
# how_long = start_time - datetime.datetime.now()
# 이처럼 -연산을 이용해 start_time으로부터 how_long까지 얼마나 남았는지 구할 수 있습니다.

# ------------------------------------------------------------------------------------------------------------

# timedelta
# timedelta 클래스
# 시간의 연산을 가능하게 해주는 클래스

# hundred_after가 지금으로부터 100일 후, 9시 정각을 값으로 가지는 datetime클래스의 인스턴스가 되도록 만들어 보세요. (단, 정각의 기준은 초 단위까지만 맞으면 됩니다.)

# import datetime

# hundred_after = datetime.datetime.now().replace(hour=9 ,minute=0,second=0) + datetime.timedelta(days = 100)

# print("{}/{}/{}  {}:{}:{}".format(hundred_after.year,hundred_after.month, hundred_after.day, hundred_after.hour, hundred_after.minute, hundred_after.second))


# timedelta 클래스를 이용하여 시간 연산을 해봅시다.

# addtime = datetime.timedelta(days = 10)
# datetime.datetime.now() + addtime    # 10일 후
# datetime.datetime.now() - addtime    # 10일 전

# thedate = datetime.datetime.now().replace(hour = 10, minute=0, second = 0)
#           + datetime.timedelta(days = 3)       # 3일 후 10시 정각
